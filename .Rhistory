library(WiTools)
install_github("Chris-Wills/R_Functions", auth_token = "7220d807f2587aa8d140f9f8aea59b935527630e")
library(devtools)
install_github("Chris-Wills/R_Functions", auth_token = "7220d807f2587aa8d140f9f8aea59b935527630e")
reverse_complement("ACGTGGGCGTGA")
library(WiTools)
reverse_complement("ACGTGGGCGTGA")
setwd("~/OneDrive - Cardiff University/PhD/R_scripts/WiTools/")
data <- seq(0.00001,1,0.001)
data <- qchisq(data, 1, lower.tail=FALSE)
??qchisq()
#' Estimate Lambda
#'
#' This function takes a vector of P-values and estimates the genomic inflation factor
#' @export
"estlambda" <- function(data, plot=FALSE, proportion=1.0,
method="regression", filter=TRUE, df=1,... ) {
data <- data[which(!is.na(data))]
if (proportion>1.0 || proportion<=0)
stop("proportion argument should be greater then zero and less than or equal to one")
ntp <- round( proportion * length(data) )
if ( ntp<1 ) stop("no valid measurements")
if ( ntp==1 ) {
warning(paste("One measurement, lambda = 1 returned"))
return(list(estimate=1.0, se=999.99))
}
if ( ntp<10 ) warning(paste("number of points is too small:", ntp))
if ( min(data)<0 ) stop("data argument has values <0")
if ( max(data)<=1 ) {
#		lt16 <- (data < 1.e-16)
#		if (any(lt16)) {
#			warning(paste("Some probabilities < 1.e-16; set to 1.e-16"))
#			data[lt16] <- 1.e-16
#		}
data <- qchisq(data, 1, lower.tail=FALSE)
}
if (filter)
{
data[which(abs(data)<1e-8)] <- NA
}
data <- sort(data)
ppoi <- ppoints(data)
ppoi <- sort(qchisq(ppoi, df=df, lower.tail=FALSE))
data <- data[1:ntp]
ppoi <- ppoi[1:ntp]
#	s <- summary(lm(data~offset(ppoi)))$coeff
#       bug fix thanks to Franz Quehenberger
out <- list()
if (method=="regression") {
s <- summary( lm(data~0+ppoi) )$coeff
out$estimate <- s[1,1]
out$se <- s[1,2]
} else if (method=="median") {
out$estimate <- median(data, na.rm=TRUE)/qchisq(0.5, df)
out$se <- NA
} else if (method=="KS") {
limits <- c(0.5, 100)
out$estimate <- estLambdaKS(data, limits=limits, df=df)
if ( abs(out$estimate-limits[1])<1e-4 || abs(out$estimate-limits[2])<1e-4 )
warning("using method='KS' lambda too close to limits, use other method")
out$se <- NA
} else {
stop("'method' should be either 'regression' or 'median'!")
}
if (plot) {
lim <- c(0, max(data, ppoi,na.rm=TRUE))
#		plot(ppoi,data,xlim=lim,ylim=lim,xlab="Expected",ylab="Observed", ...)
oldmargins <- par()$mar
par(mar=oldmargins + 0.2)
plot(ppoi, data,
xlab=expression("Expected " ~ chi^2),
ylab=expression("Observed " ~ chi^2),
...)
abline(a=0, b=1)
abline(a=0, b=out$estimate, col="red")
par(mar=oldmargins)
}
out
}
data <- seq(0.00001,1,0.001)
estlambda(data, method = "median")
estlambda(data, method = "regression")
data <- runif(10000, min=0, max=1)
estlambda(data, method = "regression")
estlambda(data, method = "median")
median(data)/qchisq(0.5,1)
estlambda(data, method = "median")
median(data, na.rm=TRUE)/qchisq(0.5, df)
median(data, na.rm=TRUE)/qchisq(0.5, 1)
#' Estimate Lambda
#'
#' This function takes a vector of P-values and estimates the genomic inflation factor
#' @export
"estlambda" <- function(data, plot=FALSE, proportion=1.0,
method="regression", filter=TRUE, df=1,... ) {
data <- data[which(!is.na(data))]
if (proportion>1.0 || proportion<=0)
stop("proportion argument should be greater then zero and less than or equal to one")
ntp <- round( proportion * length(data) )
if ( ntp<1 ) stop("no valid measurements")
if ( ntp==1 ) {
warning(paste("One measurement, lambda = 1 returned"))
return(list(estimate=1.0, se=999.99))
}
if ( ntp<10 ) warning(paste("number of points is too small:", ntp))
if ( min(data)<0 ) stop("data argument has values <0")
if ( max(data)<=1 ) {
#		lt16 <- (data < 1.e-16)
#		if (any(lt16)) {
#			warning(paste("Some probabilities < 1.e-16; set to 1.e-16"))
#			data[lt16] <- 1.e-16
#		}
data <- qchisq(data, 1, lower.tail=FALSE)
}
if (filter)
{
data[which(abs(data)<1e-8)] <- NA
}
data <- sort(data)
ppoi <- ppoints(data)
ppoi <- sort(qchisq(ppoi, df=df, lower.tail=FALSE))
data <- data[1:ntp]
ppoi <- ppoi[1:ntp]
#	s <- summary(lm(data~offset(ppoi)))$coeff
#       bug fix thanks to Franz Quehenberger
out <- list()
if (method=="regression") {
s <- summary( lm(data~0+ppoi) )$coeff
out$estimate <- s[1,1]
out$se <- s[1,2]
} else if (method=="median") {
out$estimate <- median(data, na.rm=TRUE)/qchisq(0.5, df)
out$se <- NA
} else if (method=="KS") {
limits <- c(0.5, 100)
out$estimate <- estLambdaKS(data, limits=limits, df=df)
if ( abs(out$estimate-limits[1])<1e-4 || abs(out$estimate-limits[2])<1e-4 )
warning("using method='KS' lambda too close to limits, use other method")
out$se <- NA
} else {
stop("'method' should be either 'regression' or 'median'!")
}
if (plot) {
lim <- c(0, max(data, ppoi,na.rm=TRUE))
#		plot(ppoi,data,xlim=lim,ylim=lim,xlab="Expected",ylab="Observed", ...)
oldmargins <- par()$mar
par(mar=oldmargins + 0.2)
plot(ppoi, data,
xlab=expression("Expected " ~ chi^2),
ylab=expression("Observed " ~ chi^2),
...)
abline(a=0, b=1)
abline(a=0, b=out$estimate, col="red")
par(mar=oldmargins)
}
out
}
estlambda(data, method = 'median')
estlambda(data, method = 'regression')
estlambda(data, method = 'ks')
estlambda(data, method = 'KS')
#' Estimate Lambda
#'
#' This function takes a vector of P-values and estimates the genomic inflation factor
#' @export
"estlambda" <- function(data, plot=FALSE, proportion=1.0, method="regression", filter=TRUE, df=1,... ) {
data <- data[which(!is.na(data))]
if (proportion>1.0 || proportion<=0)
stop("proportion argument should be greater then zero and less than or equal to one")
ntp <- round( proportion * length(data) )
if ( ntp<1 ) stop("no valid measurements")
if ( ntp==1 ) {
warning(paste("One measurement, lambda = 1 returned"))
return(list(estimate=1.0, se=999.99))
}
if ( ntp<10 ) warning(paste("number of points is too small:", ntp))
if ( min(data)<0 ) stop("data argument has values <0")
if ( max(data)<=1 ) {
#		lt16 <- (data < 1.e-16)
#		if (any(lt16)) {
#			warning(paste("Some probabilities < 1.e-16; set to 1.e-16"))
#			data[lt16] <- 1.e-16
#		}
data <- qchisq(data, 1, lower.tail=FALSE)
}
if (filter)
{
data[which(abs(data)<1e-8)] <- NA
}
data <- sort(data)
ppoi <- ppoints(data)
ppoi <- sort(qchisq(ppoi, df=df, lower.tail=FALSE))
data <- data[1:ntp]
ppoi <- ppoi[1:ntp]
#	s <- summary(lm(data~offset(ppoi)))$coeff
#       bug fix thanks to Franz Quehenberger
out <- list()
if (method=="regression") {
s <- summary( lm(data~0+ppoi) )$coeff
out$estimate <- s[1,1]
out$se <- s[1,2]
} else if (method=="median") {
out$estimate <- median(data, na.rm=TRUE)/qchisq(0.5, df)
out$se <- NA
} else if (method=="KS") {
limits <- c(0.5, 100)
out$estimate <- estLambdaKS(data, limits=limits, df=df)
if ( abs(out$estimate-limits[1])<1e-4 || abs(out$estimate-limits[2])<1e-4 )
warning("using method='KS' lambda too close to limits, use other method")
out$se <- NA
} else {
stop("'method' should be either 'regression' or 'median'!")
}
if (plot) {
lim <- c(0, max(data, ppoi,na.rm=TRUE))
#		plot(ppoi,data,xlim=lim,ylim=lim,xlab="Expected",ylab="Observed", ...)
oldmargins <- par()$mar
par(mar=oldmargins + 0.2)
plot(ppoi, data,
xlab=expression("Expected " ~ chi^2),
ylab=expression("Observed " ~ chi^2),
...)
abline(a=0, b=1)
abline(a=0, b=out$estimate, col="red")
par(mar=oldmargins)
}
out
}
estlambda(data, method = 'KS')
estlambda(data = data, method = 'KS')
estlambda(data = data, method = 'regression')
estlambda(data = data, method = 'median')
data <- runif(10000, min=0, max=1)
qchisq(0.05, lower.tail = F)
qchisq(0.05, lower.tail = F, df=1)
"genomic_lambda" <- function(data, input){
out <- list()
if (input = "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
out
}
"genomic_lambda" <- function(data, input){
out <- list()
if (input = "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'method' should be either 'P', 'Z' or 'chi'!")
out
}
"genomic_lambda" <- function(data, input) {
out <- list()
if (input = "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'method' should be either 'P', 'Z' or 'chi'!")
out
}
"genomic_lambda" <- function(data, input) {
out <- list()
if (input = "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
out
}
"genomic_lambda" <- function(data, input) {
out <- list()
if (input = "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input='chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
out
}
"genomic_lambda" <- function(data, input) {
out <- list()
if (input == "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
out
}
"genomic_lambda" <- function(data, input) {
out <- list()
if (input == "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
}
out
}
data <- runif(10000, min=0, max=1)
genomic_lambda(data = data, input = 'P')
genomic_lambda(data = data, input = "P")
genomic_lambda(data = data, input = "P")
"genomic_lambda" <- function(data, input="P") {
out <- list()
if (input == "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
}
out
}
data <- runif(10000, min=0, max=1)
genomic_lambda(data = data, input = "P")
"genomic_lambda" <- function(data, input) {
out <- list()
if (input == "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
}
out
}
View(genomic_lambda)
"genomic_lambda" <- function(data, input="chi") {
out <- list()
if (input == "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
if (input == 'chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
}
out
}
genomic_lambda(data = data, input = "P")
"genomic_lambda" <- function(data, input) {
out <- list()
if (input == "P") {
data_chi <- qchisq(data, 1, lower.tail=FALSE)
out$lambda <- median(data_chi, na.rm=TRUE)/qchisq(0.5,1)
}
else if (input == 'Z'){
out$lambda <- median(data^2, na.rm=TRUE)/qchisq(0.5,1)
}
else if (input == 'chi') {
out$lambda <- median(data, na.rm=TRUE)/qchisq(0.5,1)
}
else {
stop("'input' should be either 'P', 'Z' or 'chi'!")
}
out
}
genomic_lambda(data = data, input = "P")
"estlambda" <- function(data, plot=FALSE, proportion=1.0,
method="regression", filter=TRUE, df=1,... ) {
data <- data[which(!is.na(data))]
if (proportion>1.0 || proportion<=0)
stop("proportion argument should be greater then zero and less than or equal to one")
ntp <- round( proportion * length(data) )
if ( ntp<1 ) stop("no valid measurements")
if ( ntp==1 ) {
warning(paste("One measurement, lambda = 1 returned"))
return(list(estimate=1.0, se=999.99))
}
if ( ntp<10 ) warning(paste("number of points is too small:", ntp))
if ( min(data)<0 ) stop("data argument has values <0")
if ( max(data)<=1 ) {
#		lt16 <- (data < 1.e-16)
#		if (any(lt16)) {
#			warning(paste("Some probabilities < 1.e-16; set to 1.e-16"))
#			data[lt16] <- 1.e-16
#		}
data <- qchisq(data, 1, lower.tail=FALSE)
}
if (filter)
{
data[which(abs(data)<1e-8)] <- NA
}
data <- sort(data)
ppoi <- ppoints(data)
ppoi <- sort(qchisq(ppoi, df=df, lower.tail=FALSE))
data <- data[1:ntp]
ppoi <- ppoi[1:ntp]
#	s <- summary(lm(data~offset(ppoi)))$coeff
#       bug fix thanks to Franz Quehenberger
out <- list()
if (method=="regression") {
s <- summary( lm(data~0+ppoi) )$coeff
out$estimate <- s[1,1]
out$se <- s[1,2]
} else if (method=="median") {
out$estimate <- median(data, na.rm=TRUE)/qchisq(0.5, df)
out$se <- NA
} else if (method=="KS") {
limits <- c(0.5, 100)
out$estimate <- estLambdaKS(data, limits=limits, df=df)
if ( abs(out$estimate-limits[1])<1e-4 || abs(out$estimate-limits[2])<1e-4 )
warning("using method='KS' lambda too close to limits, use other method")
out$se <- NA
} else {
stop("'method' should be either 'regression' or 'median'!")
}
if (plot) {
lim <- c(0, max(data, ppoi,na.rm=TRUE))
#		plot(ppoi,data,xlim=lim,ylim=lim,xlab="Expected",ylab="Observed", ...)
oldmargins <- par()$mar
par(mar=oldmargins + 0.2)
plot(ppoi, data,
xlab=expression("Expected " ~ chi^2),
ylab=expression("Observed " ~ chi^2),
...)
abline(a=0, b=1)
abline(a=0, b=out$estimate, col="red")
par(mar=oldmargins)
}
out
}
estlambda(data, method = 'median')
data <- runif(10000, min=0, max=1)
genomic_lambda(data = data, input = "P")
estlambda(data, method = 'median')
estlambda(data, method = 'regression')
library(devtools)
library(roxygen2)
setwd("~/OneDrive - Cardiff University/PhD/R_scripts/WiTools/")
setwd("./WiTools/")
document()
document()
remove.packages("WiTools", lib="~/Library/R/3.6/library")
